/*
 * https://contest.yandex.ru/contest/23815/run-report/80335715/
 *
 * -- ПРИНЦИП РАБОТЫ --
 * В функция solve последовательно выполняются следующие операции:
 * 1. преобразование входных данных
 * 2. in-place сортировка массива по некоторому условию (данное условие подробно описано в самой задаче)
 * 3. вывод имен участников
 *
 * Рассмотрим подробнее принцип работы in-place сортировки.
 * Основная идея - отсортирвоать входныой массив без использования дополнительной памяти.
 * Для начала нужно выбрать pivot (опорный элемент), для простоты реализации в качестве
 * разделителя берется средний элемент массива, который считается по следующей формуле -
 * Math.floor((start + end) / 2). (В качестве опорного элемента можно выбрать либо рандомный элемент массива, либо самый правый элемент.)
 * После того, как pivot выбран, заводим два указателя, который по умолчанию указывают вне массива
 * слева и справа. Далее в цикле двигаем левый указатель вправо до момента, пока элемент, на который он указывает
 * не будет больше или равным pivot. Далее в отдельном цикле двигаем правый указатель влево до момента, пока он не будет
 * указывать на элемент меньше или равного pivot.
 *
 * При условии, что левый указатель догнал или перегнал правый мы выходим из цикла, в противном случаее меняем элементы местами
 * при помощи функции swap.
 *
 * Далее рекрусивно вызываем recursiveInPlaceQuickSort два раза
 * первый раз с границами [start, pivot]
 * во второй раз [pivot + 1, right]
 *
 * Почему pivot включен в первый "подмассив" при рекрусивном вызове?
 * Это необходимо, поскольку возвращаемый pivot не всегда является тем элементом, на основании которого менялись местами элементы массива
 * Рассмотрим следующий пример
 * [10, 4, 5, 2, 1]
 * pivotIndex = 2 => arr[2] = 5
 * после первой итерации
 * [1, 4, 2, 5, 10]
 * Тепер pivot равен 2, вместо 5
 *
 * Т.к. при каждом вызове функции в качестве pivot берется центральный элемент, то мы в среднем будем получать log(n) рекрусивных
 * вызовов функции recursiveInPlaceQuickSort. Где n - количество элементов в исходном массиве.
 *
 * Цикл do/while был использован по причине того, что после бесплодных часов в попытках заставить алгоритм работать с циклом while, я
 * нашел каноничную реализацию данного алгоритма в wikipedia https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
 *
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * Рассмотрим функцию inPlaceQuickSort
 *
 * На каждом слое рекурсии происходит "разбиение" массива на под-массивы таким образом, что в первом массиве оказываются
 * элементы которые меньше или равны pivot + текущий pivot, а во втором все оставшиеся элементы. Каждый раз в качестве pivot будет браться элемент, который
 * является центральным в текущем массиве. Разбиение остановится, если подмассив пустой или содержит всего один элемент. Это и есть базовый случай рекурсии.
 *
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * Не берем в расчет время затраченное на считывание иссходных данных
 *
 *  Для преобразования исходного массива строк нам потребуется O(n) операций
 *
 * Рассмотрим временную сложность функции inPlaceQuickSort
 * Начнем с рассмтотрения worst-case сценария. Даже если выбирать в качестве pivot элемента центральный элемент массива, то на вход может
 * быть подан массив при котором на каждом уровне рекурсии в качестве pivot будет выбран либо самый большой/меньший элемент подмасива
 * При таком сценарии мы получим n - 1 рекрусивных вызовов функции и тоговая сложность будет O(n * (n-1)) ~ O(n^2)
 *
 * На практике довольно сложно подобрать такой набор данных, при которых сложность будет квадратичной.
 * В среднем, на каждом уровне рекурсии массив будет делиться на примерно две равные части и в таком случае глубина рекурсии составит log(n).
 * Также стоит отметить, что на каждом уровне рекурсии будет просмотрено n элементов, что приводит нас к тому, что итоговая сложность данной функции
 * в среднем равна O(n * log(n))
 *
 * Для преобразоваия отсортированного массива нам потребуется снова O(n) операций
 *
 * Итоговая времнная сложность алгоритма O(n + nlog(n) + n) ~ O(nlog(n)) (поскольку nlog(n) растет быстрее чем O(n), следовательно
 * O(n) в итоговой оценке можно опустить
 *
 * Под n подразумевается количество элементов в исходном массиве.
 *
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Не берем в расчет память затраченную на считывание данных и запись в массив inputLines.
 *
 * Для преобразование исходного массива строк в массив, содержащий массивы из трех элементов нам потребуется O(n * t) ~ O(n * 1) ~ O(n) памяти
 * Где n - число элементов в исходном массиве, а t - память затраченная на хранения массива из трех элементов, примем это за константу
 *
 * Функция inPlaceQuickSort осуществляет сортировку массива на месте, следовательно нам не нужна дополнительная память для самой сортировки.
 * Отметим также, что функция swap осуществляеют перестановку двух элементов используя каждый раз новую переменную. Это никак не влияет на итоговый объем
 * потребляемой памяти, поскольку переменная каждый раз удаляется. Можно провести оптимизация и реализовать данную функцию без использования временной переменной,
 * вместо этого использовать XOR.
 * Будем ссчитать, что указатели, которые создаются во время работы recursiveInPlaceQuickSort потребляют константное количество памяти O(1)
 * Поскольку функция рекрусивна, то на каждый новый слой рекурсии тратится некоторая память, обозначим это как O(log(n))
 *
 * Для преобразования отсортированного массива в массив имен нам необходимо затратить дополнительно O(n) памяти
 * Итогова пространственная сложность всего алгоритма будет равна O(n) + O(log(n)) + O(n) ~ 2O(n) ~ O(n)
 */

const readline = require('readline');
const ioInterface = readline.createInterface({ input: process.stdin });

const inputLines = [];

ioInterface.on('line', line => {
  inputLines.push(line);
});

ioInterface.on('close', solve);

function solve() {
  const participantTable = parseInput();

  inPlaceQuickSort(participantTable, compareParticipantsResults);

  printArray(participantTable.map(([name]) => name));
}

function compareParticipantsResults(participantA, participantB) {
  const NAME = 0;
  const SCORE = 1;
  const FINE = 2;
  if (participantA[SCORE] > participantB[SCORE]) {
    return -1;
  } else if (participantA[SCORE] < participantB[SCORE]) {
    return 1;
  }
  // at this point scores are equal

  if (participantA[FINE] > participantB[FINE]) {
    return 1;
  } else if (participantA[FINE] < participantB[FINE]) {
    return -1;
  }
  // at this point both scores and fines are equal

  if (participantA[NAME] < participantB[NAME]) {
    return -1;
  } else if (participantA[NAME] > participantB[NAME]) {
    return 1;
  }

  return 0;
}

function parseInput() {
  const numberOfParticipants = inputLines[0];
  const participantTable = [];

  for (let i = 1; i <= numberOfParticipants; i++) {
    const [participant, score, fine] = inputLines[i].split(' ');
    participantTable.push([participant, Number(score), Number(fine)]);
  }

  return participantTable;
}

function printArray(array) {
  print(array.join('\n'));
}

function print(text) {
  process.stdout.write(`${text}\n`);
}

function inPlaceQuickSort(arr, compare = (a, b) => a - b) {
  recursiveInPlaceQuickSort(0, arr.length - 1);

  function recursiveInPlaceQuickSort(start, end) {
    if (start >= end) {
      return;
    }
    const pivotIndex = Math.floor((start + end) / 2);
    const pivot = arr[pivotIndex];
    let leftP = start - 1;
    let rightP = end + 1;

    while (leftP < rightP) {
      do {
        leftP++;
      } while (compare(arr[leftP], pivot) < 0);

      do {
        rightP--;
      } while (compare(arr[rightP], pivot) > 0);

      if (leftP >= rightP) {
        break;
      }

      swap(arr, leftP, rightP);
    }

    recursiveInPlaceQuickSort(start, rightP);
    recursiveInPlaceQuickSort(rightP + 1, end);
  }
}

function swap(arr, leftP, rightP) {
  const temp = arr[rightP];
  arr[rightP] = arr[leftP];
  arr[leftP] = temp;
}
